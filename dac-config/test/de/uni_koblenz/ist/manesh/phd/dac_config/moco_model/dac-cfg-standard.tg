// JGraLab - The Java graph laboratory
//   Version : 7.7.12
//   Codename: Giraffatitan
TGraph 2;
Schema de.uni_koblenz.ist.manesh.phd.case_studies.dac.DACMetaModel;
GraphClass DacGraph["The relationships of type Alternative and Or must have at least two targets.""import arithmetics.*; forall r : V{Alternative, Or} @ r.targets <> null and count(r.targets) >= 2""import arithmetics.*; from r : V {Alternative, Or} with r.targets = null or count(r.targets) < 2"]["The relationships of type Implication, Exclusion, Mandatory and Optional must have exactly one target.""import arithmetics.*; forall r : V{Implication, Exclusion, Mandatory, Optional} @ r.targets <> null and count(r.targets) = 1""import arithmetics.*; from r : V{Implication, Exclusion, Mandatory, Optional} with r.targets = null or count(r.targets) <> 1"];
abstract VertexClass NamedElement{uniqueName:String,visibleName:String}["A NamedElement's name may not start with __ (two underscores)""forall ne : V{rooms.NamedElement} @ not(startsWith('__', ne.name))""from ne : V{rooms.NamedElement} with startsWith('__', ne.name) reportSet ne end"]["Each name of a NamedElement must be unique in the model.""forall ne1, ne2 : V{rooms.NamedElement} @ isDefined(ne1.name) and isDefined(ne2.name) and ne1.name <> ne2.name""from n1, n2 : V{rooms.NamedElement} with isDefined(n1.name) and isDefined(n2.name) and n1.name <> n2.name report n1, n2. end"]["The name of a NamedElement may not be null.""forall ne : V{rooms.NamedElement} @ isDefined(ne)""from ne : V{rooms.NamedElement} with isUndefined(ne) report ne end"];
Package eca_rules;
VertexClass Action{methodName:String,params:List<String>};
Comment Action"The&nbsp;\"params\"&nbsp;attribute may contain property paths. To differentiate them from pure string values,\n</br>they always start with an \"__\".";
VertexClass Condition{greqlBooleanExpression:String};
VertexClass EventObject{timeStamp:Long}["There may be at most one event object at any time""count(V{eca_rules.EventObject}) <= 1""from e : V{eca_rules.EventObject} reportSet e end"];
VertexClass EventType{id:String};
VertexClass Rule:.NamedElement{priority:Integer};
EdgeClass HasAction from Rule(0,*)role rules to Action(1,*)role actions;
EdgeClass HasCondition from Rule(0,*)role rules to Condition(1,1)role condition aggregation shared;
EdgeClass HasEventType from EventObject(0,1)role eventObject to EventType(1,1)role eventType aggregation shared;
EdgeClass HasObject from EventObject(0,1)to .NamedElement(1,1)role object aggregation shared;
EdgeClass HasSubject from EventObject(0,1)to .NamedElement(1,1)role subject aggregation shared;
EdgeClass OnEvent from Rule(0,*)role rules to EventType(1,1)role eventType aggregation shared;
Package features;
VertexClass Alternative:Relationship;
VertexClass Exclusion:Relationship;
VertexClass Feature:.NamedElement{description:String,selected:Boolean};
VertexClass Implication:Relationship;
VertexClass Mandatory:Relationship;
VertexClass Optional:Relationship;
VertexClass Or:Relationship;
abstract VertexClass Relationship;
EdgeClass ComesFrom from Relationship(0,*)role outgoings to Feature(1,1)role source;
EdgeClass GoesTo from Relationship(0,1)role incoming to Feature(1,*)role targets;
EdgeClass ImplementedBy from Feature(0,*)role feature to features.solution.ImplementationElement(0,*)role implElement;
Package rooms;
VertexClass CameraSensor:RoomSensor;
VertexClass CardReaderSensor:Sensor;
VertexClass Door:.NamedElement,Positionable{locked:Boolean,vertical:Boolean};
Comment Door"This assumes a directional view on doors and rooms.\n</br>From and To are purely conceptual and depend on the perspective (side of Door).";
VertexClass MidRangeRFIDSensor:RoomSensor;
VertexClass Person:.NamedElement;
abstract VertexClass Positionable{x:Integer,y:Integer};
VertexClass Role:.NamedElement;
VertexClass Room:.NamedElement,Positionable{height:Integer,width:Integer};
abstract VertexClass RoomSensor:Sensor;
abstract VertexClass Sensor:.NamedElement,Positionable{productId:String};
EdgeClass From from Door(0,*)role entries to Room(1,1)role sourceRoom;
EdgeClass HasCardReaderSensor from Door(1,1)role protectedDoor to CardReaderSensor(0,1)role cardReaderSensor;
EdgeClass HasRole from Person(0,*)role person to Role(1,*)role roles aggregation shared;
EdgeClass HasRoomSensor from Room(1,1)role protectedRoom to RoomSensor(0,*)role sensors;
EdgeClass IsInRoom from Person(0,*)role persons to Room(0,1)role room;
Comment IsInRoom"Person&nbsp;may&nbsp;be&nbsp;out&nbsp;of&nbsp;this&nbsp;world&nbsp;;-)";
EdgeClass To from Door(0,*)role exits to Room(1,1)role targetRoom;
Package features.solution;
abstract VertexClass ImplementationElement:.NamedElement;
VertexClass OSGiBundle:ImplementationElement;
Graph"5a0ec6a4-c507-4b82-b45c-03318b819296"250 DacGraph(100 100 51 50);
Package eca_rules;
1 EventObject<>u;
Package rooms;
2 Room<7 -8 -11 -14 -21 -26 -30 -32 -34 -36>8"Hallway"u 8 0 0;
3 Room<1 -9>3"R1"u 2 0 0;
4 Room<2 -12 -15>3"R2"u 3 2 0;
5 Room<3 -18>2"R3"u 2 0 4;
6 Room<4 -20>2"R4"u 2 0 6;
7 Room<5 -17 -19 -22 -25>4"R5"u 3 2 4;
8 Room<6 -24 -27>4"R6"u 3 5 4;
9 CameraSensor<-1>"Camera""R1S1"u 0 0;
10 CameraSensor<-2>"Camera""R2S1"u 2 0;
11 CameraSensor<-3>"Camera""R3S1"u 0 4;
12 CameraSensor<-4>"Camera""R4S1"u 0 6;
13 CameraSensor<-5>"Camera""R5S1"u 3 8;
14 CameraSensor<-6>"Camera""R6S1"u 7 8;
15 CameraSensor<-7>"Camera""HallwayS1"u 8 4;
16 Door<8 9 10>t"R1D"f u 1 3;
17 CardReaderSensor<-10>"Card-Reader""R1DS"u 1 3;
18 Door<11 12 13>t"R2D1"f u 3 3;
19 CardReaderSensor<-13>"Card-Reader""R2D1S"u 3 3;
20 Door<14 15 16>t"R2D2"t u 5 1;
21 CardReaderSensor<-16>"Card-Reader""R2D2S"u 5 1;
22 Door<17 18>t"R3D"t u 2 4;
23 Door<19 20>t"R4D"t u 2 6;
24 Door<21 22 23>t"R5D1"f u 3 4;
25 CardReaderSensor<-23>"Card-Reader""R5D1S"u 3 4;
26 Door<24 25>t"R5D2"t u 5 5;
27 Door<26 27 28>t"R6D"f u 6 4;
28 CardReaderSensor<-28>"Card-Reader""R6DS"u 6 4;
29 Role<-31>"MANAGER"u;
30 Role<-29>"EMPLOYEE"u;
31 Role<-33>"VIP"u;
32 Role<-35>"GUEST"u;
33 Person<29 30>"P1"u;
34 Person<31 32>"P2"u;
35 Person<33 34>"P3"u;
36 Person<35 36>"P4"u;
Package features;
37 Feature<-41 -43>u t"DacsFeatures"u;
38 Feature<-42 -45>u t"AccessRuleType"u;
39 Feature<-46>u t"Fixed"u;
40 Feature<37 38 -47>u f"Adaptable"u;
Package features.solution;
41 OSGiBundle<-37>"dac-rule-editor"u;
42 OSGiBundle<-38>"dac-command-line"u;
Package features;
43 Feature<-44 -48>u t"UserIdentification"u;
44 Feature<39 -49>u t"CardReader"u;
Package features.solution;
45 OSGiBundle<-39>"dac-card-reader-driver"u;
Package features;
46 Feature<40 -50>u f"Camera"u;
Package features.solution;
47 OSGiBundle<-40>"dac-camera-driver"u;
Package features;
48 Mandatory<41 42>;
49 Mandatory<43 44>;
50 Alternative<45 46 47>;
51 Or<48 49 50>;
Package rooms;
1 HasRoomSensor;
2 HasRoomSensor;
3 HasRoomSensor;
4 HasRoomSensor;
5 HasRoomSensor;
6 HasRoomSensor;
7 HasRoomSensor;
8 From;
9 To;
10 HasCardReaderSensor;
11 From;
12 To;
13 HasCardReaderSensor;
14 From;
15 To;
16 HasCardReaderSensor;
17 From;
18 To;
19 From;
20 To;
21 From;
22 To;
23 HasCardReaderSensor;
24 From;
25 To;
26 From;
27 To;
28 HasCardReaderSensor;
29 HasRole;
30 IsInRoom;
31 HasRole;
32 IsInRoom;
33 HasRole;
34 IsInRoom;
35 HasRole;
36 IsInRoom;
Package features;
37 ImplementedBy;
38 ImplementedBy;
39 ImplementedBy;
40 ImplementedBy;
41 ComesFrom;
42 GoesTo;
43 ComesFrom;
44 GoesTo;
45 ComesFrom;
46 GoesTo;
47 GoesTo;
48 ComesFrom;
49 GoesTo;
50 GoesTo;
