// JGraLab - The Java graph laboratory
//   Version : 8.0.8
//   Codename: Hylonomus
TGraph 3;
Schema de.uni_koblenz.ist.manesh.phd.case_studies.dac.DACMetaModel;
GraphClass 0 DacGraph["The relationships of type Alternative and Or must have at least two targets.""import arithmetics.*; forall r : V{Alternative, Or} @ r.targets <> null and count(r.targets) >= 2""import arithmetics.*; from r : V {Alternative, Or} with r.targets = null or count(r.targets) < 2"]["The relationships of type Implication, Exclusion, Mandatory and Optional must have exactly one target.""import arithmetics.*; forall r : V{Implication, Exclusion, Mandatory, Optional} @ r.targets <> null and count(r.targets) = 1""import arithmetics.*; from r : V{Implication, Exclusion, Mandatory, Optional} with r.targets = null or count(r.targets) <> 1"];
abstract VertexClass 1 NamedElement{uniqueName:String,visibleName:String}["A NamedElement's name may not start with __ (two underscores)""forall ne : V{rooms.NamedElement} @ not(startsWith('__', ne.name))""from ne : V{rooms.NamedElement} with startsWith('__', ne.name) reportSet ne end"]["Each name of a NamedElement must be unique in the model.""forall ne1, ne2 : V{rooms.NamedElement} @ isDefined(ne1.name) and isDefined(ne2.name) and ne1.name <> ne2.name""from n1, n2 : V{rooms.NamedElement} with isDefined(n1.name) and isDefined(n2.name) and n1.name <> n2.name report n1, n2. end"]["The name of a NamedElement may not be null.""forall ne : V{rooms.NamedElement} @ isDefined(ne)""from ne : V{rooms.NamedElement} with isUndefined(ne) report ne end"];
Package eca_rules;
VertexClass 2 Action{methodName:String,params:List<String>};
Comment Action"The&nbsp;\"params\"&nbsp;attribute may contain property paths. To differentiate them from pure string values,\n</br>they always start with an \"__\".";
VertexClass 3 Condition{greqlBooleanExpression:String};
VertexClass 4 EventObject{timeStamp:Long}["There may be at most one event object at any time""count(V{eca_rules.EventObject}) <= 1""from e : V{eca_rules.EventObject} reportSet e end"];
VertexClass 5 EventType{id:String};
VertexClass 6 Rule:.NamedElement{priority:Integer};
VertexClass 7 Rules;
EdgeClass 8 ContainsRules from Rules(1,1)role ruleModel to Rule(0,*)role rules aggregation composite;
EdgeClass 9 HasAction from Rule(0,*)role rules to Action(1,*)role actions;
EdgeClass 10 HasCondition from Rule(0,*)role rules to Condition(1,1)role condition aggregation shared;
EdgeClass 11 HasEventType from EventObject(0,1)role eventObject to EventType(1,1)role eventType aggregation shared;
EdgeClass 12 HasObject from EventObject(0,1)to .NamedElement(1,1)role object aggregation shared;
EdgeClass 13 HasSubject from EventObject(0,1)to .NamedElement(1,1)role subject aggregation shared;
EdgeClass 14 OnEvent from Rule(0,*)role rules to EventType(1,1)role eventType aggregation shared;
Package features;
VertexClass 15 Alternative:Relationship;
VertexClass 16 Exclusion:Relationship;
VertexClass 17 Feature:.NamedElement{description:String,selected:Boolean};
VertexClass 18 Features;
VertexClass 19 Implication:Relationship;
VertexClass 20 Mandatory:Relationship;
VertexClass 21 Optional:Relationship;
VertexClass 22 Or:Relationship;
abstract VertexClass 23 Relationship;
EdgeClass 24 ComesFrom from Relationship(0,*)role outgoings to Feature(1,1)role source;
EdgeClass 25 ContainsFeatures from Features(1,1)role featureModel to Feature(0,*)role features aggregation composite;
EdgeClass 26 GoesTo from Relationship(0,1)role incoming to Feature(1,*)role targets;
EdgeClass 27 ImplementedBy from Feature(0,*)role feature to features.solution.ImplementationElement(0,*)role implElement;
Package persons;
VertexClass 28 Person:.NamedElement;
VertexClass 29 Persons;
VertexClass 30 Role:.NamedElement;
EdgeClass 31 ContainsPersons from Persons(1,1)role personModel to Person(0,*)role persons aggregation composite;
EdgeClass 32 HasRole from Person(0,*)role person to Role(1,*)role roles aggregation shared;
EdgeClass 33 IsInRoom from Person(0,*)role persons to rooms.Room(0,1)role room;
Package rooms;
VertexClass 34 CameraSensor:RoomSensor;
VertexClass 35 CardReaderSensor:Sensor;
VertexClass 36 Door:.NamedElement,Positionable{locked:Boolean,vertical:Boolean};
Comment Door"This assumes a directional view on doors and rooms.\n</br>From and To are purely conceptual and depend on the\n</br>perspective (side of Door).";
VertexClass 37 MidRangeRFIDSensor:RoomSensor;
abstract VertexClass 38 Positionable{x:Integer,y:Integer};
VertexClass 39 Room:.NamedElement,Positionable{height:Integer,width:Integer};
abstract VertexClass 40 RoomSensor:Sensor;
VertexClass 41 Rooms;
abstract VertexClass 42 Sensor:.NamedElement,Positionable{productId:String};
EdgeClass 43 ContainsRooms from Rooms(1,1)role roomModel to Room(0,*)role rooms aggregation composite;
EdgeClass 44 From from Door(0,*)role entries to Room(1,1)role sourceRoom;
EdgeClass 45 HasCardReaderSensor from Door(1,1)role protectedDoor to CardReaderSensor(0,1)role cardReaderSensor;
EdgeClass 46 HasRoomSensor from Room(1,1)role protectedRoom to RoomSensor(0,*)role sensors;
EdgeClass 47 To from Door(0,*)role exits to Room(1,1)role targetRoom;
Package features.solution;
abstract VertexClass 48 ImplementationElement:.NamedElement;
VertexClass 49 OSGiBundle:ImplementationElement;
Graph"12220dc4-9093-4f5a-9487-1fa548dde941"272 0(100 100 55 68);
1 4<>u;
2 7<>;
3 41<1 2 3 4 5 6 7>;
4 39<-1 14 -15 -18 -21 -28 -33 -38 -41 -44 -47>8"Hallway"u 8 0 0;
5 39<-2 8 -16>3"R1"u 2 0 0;
6 39<-3 9 -19 -22>3"R2"u 3 2 0;
7 39<-4 10 -25>2"R3"u 2 0 4;
8 39<-5 11 -27>2"R4"u 2 0 6;
9 39<-6 12 -24 -26 -29 -32>4"R5"u 3 2 4;
10 39<-7 13 -31 -34>4"R6"u 3 5 4;
11 34<-8>"Camera""R1S1"u 0 0;
12 34<-9>"Camera""R2S1"u 2 0;
13 34<-10>"Camera""R3S1"u 0 4;
14 34<-11>"Camera""R4S1"u 0 6;
15 34<-12>"Camera""R5S1"u 3 8;
16 34<-13>"Camera""R6S1"u 7 8;
17 34<-14>"Camera""HallwayS1"u 8 4;
18 36<15 16 17>t"R1D"f u 1 3;
19 35<-17>"Card-Reader""R1DS"u 1 3;
20 36<18 19 20>t"R2D1"f u 3 3;
21 35<-20>"Card-Reader""R2D1S"u 3 3;
22 36<21 22 23>t"R2D2"t u 5 1;
23 35<-23>"Card-Reader""R2D2S"u 5 1;
24 36<24 25>t"R3D"t u 2 4;
25 36<26 27>t"R4D"t u 2 6;
26 36<28 29 30>t"R5D1"f u 3 4;
27 35<-30>"Card-Reader""R5D1S"u 3 4;
28 36<31 32>t"R5D2"t u 5 5;
29 36<33 34 35>t"R6D"f u 6 4;
30 35<-35>"Card-Reader""R6DS"u 6 4;
31 30<-40>"MANAGER"u;
32 30<-37>"EMPLOYEE"u;
33 30<-43>"VIP"u;
34 30<-46>"GUEST"u;
35 29<36 39 42 45>;
36 28<-36 37 38>"P1"u;
37 28<-39 40 41>"P2"u;
38 28<-42 43 44>"P3"u;
39 28<-45 46 47>"P4"u;
40 18<48 49 50 51 54 55 57>;
41 17<-48 -59 -61>u t"DacsFeatures"u;
42 17<-49 -60 -63>u t"AccessRuleType"u;
43 17<-50 -64>u f"Fixed"u;
44 17<-51 52 53 -65>u t"Adaptable"u;
45 49<-52>"dac-rule-editor"u;
46 49<-53>"dac-command-line"u;
47 17<-54 -62 -66>u t"UserIdentification"u;
48 17<-55 56 -67>u t"CardReader"u;
49 49<-56>"dac-card-reader-driver"u;
50 17<-57 58 -68>u t"Camera"u;
51 49<-58>"dac-camera-driver"u;
52 20<59 60>;
53 20<61 62>;
54 15<63 64 65>;
55 22<66 67 68>;
1 43;
2 43;
3 43;
4 43;
5 43;
6 43;
7 43;
8 46;
9 46;
10 46;
11 46;
12 46;
13 46;
14 46;
15 44;
16 47;
17 45;
18 44;
19 47;
20 45;
21 44;
22 47;
23 45;
24 44;
25 47;
26 44;
27 47;
28 44;
29 47;
30 45;
31 44;
32 47;
33 44;
34 47;
35 45;
36 31;
37 32;
38 33;
39 31;
40 32;
41 33;
42 31;
43 32;
44 33;
45 31;
46 32;
47 33;
48 25;
49 25;
50 25;
51 25;
52 27;
53 27;
54 25;
55 25;
56 27;
57 25;
58 27;
59 24;
60 26;
61 24;
62 26;
63 24;
64 26;
65 26;
66 24;
67 26;
68 26;
