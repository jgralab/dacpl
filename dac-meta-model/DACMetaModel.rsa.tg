TGraph 2;

Schema de.uni_koblenz.ist.manesh.phd.case_studies.dac.DACMetaModel;

GraphClass DacGraph ["The relationships of type Implication, Exclusion, Mandatory and Optional must have exactly one target." "import arithmetics.*; forall r : V{Implication, Exclusion, Mandatory, Optional} @ r.targets <> null and count(r.targets) = 1" "import arithmetics.*; from r : V{Implication, Exclusion, Mandatory, Optional} with r.targets = null or count(r.targets) <> 1"] ["The relationships of type Alternative and Or must have at least two targets." "import arithmetics.*; forall r : V{Alternative, Or} @ r.targets <> null and count(r.targets) >= 2" "import arithmetics.*; from r : V {Alternative, Or} with r.targets = null or count(r.targets) < 2"];

abstract VertexClass NamedElement {uniqueName: String, visibleName: String} ["Each name of a NamedElement must be unique in the model." "forall ne1, ne2 : V{rooms.NamedElement} @ isDefined(ne1.name) and isDefined(ne2.name) and ne1.name <> ne2.name" "from n1, n2 : V{rooms.NamedElement} with isDefined(n1.name) and isDefined(n2.name) and n1.name <> n2.name report n1, n2. end"] ["The name of a NamedElement may not be null." "forall ne : V{rooms.NamedElement} @ isDefined(ne)" "from ne : V{rooms.NamedElement} with isUndefined(ne) report ne end"] ["A NamedElement's name may not start with __ (two underscores)" "forall ne : V{rooms.NamedElement} @ not(startsWith('__', ne.name))" "from ne : V{rooms.NamedElement} with startsWith('__', ne.name) reportSet ne end"];
Package rooms;
Comment rooms.Door "This assumes a directional view on doors and rooms.\n</br>From and To are purely conceptual and depend on the\n</br>perspective (side of Door).";
VertexClass Door: .NamedElement, Positionable {locked: Boolean, vertical: Boolean};
VertexClass Room: .NamedElement, Positionable {width: Integer, height: Integer};
VertexClass CardReaderSensor: Sensor;
VertexClass MidRangeRFIDSensor: RoomSensor;
VertexClass CameraSensor: RoomSensor;
abstract VertexClass Sensor: .NamedElement, Positionable {productId: String};
EdgeClass HasCardReaderSensor from Door (1,1) role protectedDoor to CardReaderSensor (0,1) role cardReaderSensor;
EdgeClass HasRoomSensor from Room (1,1) role protectedRoom to RoomSensor (0,*) role sensors;
abstract VertexClass RoomSensor: Sensor;
abstract VertexClass Positionable {x: Integer, y: Integer};
EdgeClass From from Door (0,*) role entries to Room (1,1) role sourceRoom;
EdgeClass To from Door (0,*) role exits to Room (1,1) role targetRoom;
VertexClass Rooms;
EdgeClass ContainsRooms from Rooms (1,1) role roomModel to Room (0,*) role rooms aggregation composite;
Package eca_rules;
VertexClass Rule: .NamedElement {priority: Integer};
VertexClass EventType {id: String};
VertexClass Condition {greqlBooleanExpression: String};
Comment eca_rules.Action "The&nbsp;\"params\"&nbsp;attribute may contain property paths. To differentiate them from pure string values,\n</br>they always start with an \"__\".";
VertexClass Action {methodName: String, params: List<String>};
EdgeClass OnEvent from Rule (0,*) role rules to EventType (1,1) role eventType aggregation shared;
EdgeClass HasCondition from Rule (0,*) role rules to Condition (1,1) role condition aggregation shared;
EdgeClass HasAction from Rule (0,*) role rules to Action (1,*) role actions;
VertexClass EventObject {timeStamp: Long} ["There may be at most one event object at any time" "count(V{eca_rules.EventObject}) <= 1" "from e : V{eca_rules.EventObject} reportSet e end"];
EdgeClass HasSubject from EventObject (0,1) to .NamedElement (1,1) role subject aggregation shared;
EdgeClass HasObject from EventObject (0,1) to .NamedElement (1,1) role object aggregation shared;
EdgeClass HasEventType from EventObject (0,1) role eventObject to EventType (1,1) role eventType aggregation shared;
VertexClass Rules;
EdgeClass ContainsRules from Rules (1,1) role ruleModel to Rule (0,*) role rules aggregation composite;
Package features;
VertexClass Or: Relationship;
VertexClass Alternative: Relationship;
VertexClass Optional: Relationship;
abstract VertexClass Relationship;
VertexClass Feature: .NamedElement {description: String, selected: Boolean};
VertexClass Mandatory: Relationship;
VertexClass Implication: Relationship;
VertexClass Exclusion: Relationship;
EdgeClass GoesTo from Relationship (0,1) role incoming to Feature (1,*) role targets;
EdgeClass ComesFrom from Relationship (0,*) role outgoings to Feature (1,1) role source;
EdgeClass ImplementedBy from Feature (0,*) role feature to features.solution.ImplementationElement (0,*) role implElement;
VertexClass Features;
EdgeClass ContainsFeatures from Features (1,1) role featureModel to Feature (0,*) role features aggregation composite;
Package features.solution;
abstract VertexClass ImplementationElement: .NamedElement;
VertexClass OSGiBundle: ImplementationElement;
Package persons;
VertexClass Person: .NamedElement;
VertexClass Role: .NamedElement;
EdgeClass HasRole from Person (0,*) role person to Role (1,*) role roles aggregation shared;
EdgeClass IsInRoom from Person (0,*) role persons to rooms.Room (0,1) role room;
VertexClass Persons;
EdgeClass ContainsPersons from Persons (1,1) role personModel to Person (0,*) role persons aggregation composite;

